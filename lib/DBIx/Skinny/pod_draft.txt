#DBIx::Skinny::AR - DBIx::Skinny's wrapper based on Any::Moose


=head1 SYNOPSIS
=cut

DBIx::SkinnyをMyApp::DB, MyApp::DB::Schemaでsetupしている場合、まず以下のようにベースクラスを定義します。

  package MyApp::AR;
  use Any::Moose;
  extends 'DBIx::Skinnh::AR';

  __PACKAGE__->setup('MyApp::DB');

  1;

DBのテーブルに対応したモデルクラスを作成します。各モデルクラスはMyApp::ARを継承します。

  package MyApp::Book;
  use Any::Moose;
  extends 'MyApp::AR';

  has 'id' => (
      is  => 'rw',
      isa => 'Undef | Int',
  );

  has 'author_id' => (
      is  => 'rw',
      isa => 'Undef | Int',
  );

  has 'title' => (
      is     => 'rw',
      isa    => 'Str',
      traits => [qw/Unique/],
  );

  __PACKAGE__->belongs_to('author');

  1;


=head1 DESCRIPTION
=cut

=head1 INHERITED METHODS

=head2 table

テーブル名

=head2 columns

テーブルが持つカラムの一覧

=head2 pk

テーブルのprimary key

=head2 row

DBIx::Skinny::Rowオブジェクトが格納される


=head1 DEFINE ATTRIBUTES

=head2 each columns

テーブルが持っているカラムをそれぞれアトリビュートとして登録してやる必要があります。

has 'id' => (
    is  => 'rw',
    isa => 'Undef | Int',
);

DBとクラスでそれぞれカラムを定義するのは二度手間に思えるかも知れません。
しかし、DBのスキーマとアプリケーションのモデルは必ずしも一致する物ではありません。
より自由な制御を可能とするため、DBIx::Skinny::ARではオブジェクトを通してアクセスする
アトリビュートは全て記述するように設計しています。

=head2 unique constraint

あるアトリビュートにユニーク制約を適用したい場合は、以下のようにtraisを指定します。

has 'name' => (
    is      => 'rw',
    isa     => 'Str',
    traits  => [qw/Unique/],
);

DBからレコードを読み込んだ時、オブジェクトの該当アトリビュートを書き換えた時にDBに対してユニークであることを確認します。


=head1 METHODS
=cut

=head2 find
=cut

  my $book = MyApp::Book->find(1);
  my $book = MyApp::Book->find({ id => 1 });
  my $book = MyApp::Book->find({ name => 'book1' });

  my $book = MyApp::Book->find(
      { author_id => 1 },
      { order_by  => { id => 'desc' } },
  );

  my $model = MyApp::Book->new;
  my $book = $model->find(1);

=head2 find_all
=cut

  my $books = MyApp::Book->find_all;
  my $books = MyApp::Book->find_all({ author_id => 1 });

  my $books = MyApp::Book->find_all(
      { author_id => 1 },
      { order_by  => { id => 'desc' } },
  );

=head2 count
=cut

  my $cnt = MyApp::Book->count;
  my $cnt = MyApp::Book->count({ author_id => 1 });

=head2 reload
=cut

  my $book = MyApp::Book->find(1);
  # DB updated
  $book->reload;

=head2 create
=cut

  my $new_book = MyApp::Book->create({
      author_id => 1,
      name      => 'new book',
  });

=head2 update
=cut

  my $book = MyApp::Book->find(1);
  $book->name('name updated');
  $book->update;

  MyApp::Book->update(
      { name => 'my book' },
      { author_id => 1 }
  );

updateをクラスメソッドとして実行する場合はwhere節が必要です。
指定が無い場合は例外をthrowします。

=head2 delete
=cut

  my $book = MyApp::Book->find(1);
  $book->delete;

  MyApp::Book->delete({ id => 1 });

=head1 クラスの命名規則

必ずしも従う必要はありませんが、この形式に合わせておくとリレーションの設定に複雑なオプションが不要になります。

-クラス名は単数形（MyApp::Bookなど）
-テーブル名は複数形（booksなど）

=head1 RELATIONSHIPS
=cut

=head2 belongs_to
=cut

クラスの命名規則に従っていれば、

__PACKAGE__->belongs_to('author');

のようにbelongs_toに関連するオブジェクトを取得するメソッドの名前を渡してやるだけで、リレーションの設定ができます。

以下のようにオプションを記述することで、リレーションの詳細なパラメータを設定することも可能です。

__PACKAGE__->belongs_to(
    'author' => {
        self_key     => 'author_id',
        target_class => 'MyApp::Author',
        target_key   => 'id',
    }
);

オプションを指定しない場合は各項目が以下のように設定されます。

self_key     ... メソッド名_対象クラスのPK
target_class ... 呼び出し元のクラスの名前空間::メソッド名
target_key   ... 対象クラスのPK

アプリケーションでは、以下のように使用します。

my $book = MyApp::Book->find(1);
my $author = $book->author;
warn ref $author # MyApp::Author

$book->authorで読み出したオブジェクトは、$bookのアトリビュートとして保持されます。
再度$book->authorを参照しても、DBに対してSQLが発行されません。

DBからレコードを読み直したい時は、明示的にauthorをクリアします。
$book->clear_author;

=head2 has_one
=cut

__PACKAGE__->has_one('book');

__PACKAGE__->has_one(
    'book' => {
        self_key     => 'id',
        target_class => 'MyApp::Book',
        target_key   => 'author_id',
    }
);

オプションを指定しない場合のデフォルト値は以下の通りです。

self_key     ... 自身のPK
target_class ... 自身の名前空間::メソッド名
target_key   ... 自身のクラス名_PK

my $author = MyApp::Author->find(1);
my $book = $author->book;

=head2 has_many
=cut

__PACKAGE__->has_many('books');

__PACKAGE__->has_many(
    'books' => {
        self_key     => 'id',
        target_class => 'MyApp::Book',
        target_key   => 'author_id',
    }
);

オプションを指定しない場合のデフォルト値は以下の通りです。

self_key     ... 自身のPK
target_class ... 自身の名前空間::メソッド名（単数形に変換）
target_key   ... 自身のクラス名_PK

my $author = MyApp::Author->find(1);
my $books = $author->books;

=head2 many_to_many
=cut

+------------------+
|     books        |
+------------------+
| id (PK)          |
| name             |
+------------------+

+------------------+
|    categories    |
+------------------+
| id (PK)          |
| name             |
+------------------+

+------------------+
| books_categories |
+------------------+
| id (PK)          |
| book_id          |
| category_id      |
+------------------+

many_to_manyは、図のように中間テーブルを用いてn:nの関係を表す時に使用します。

現在のところDBIx::Skinnyでは、テーブルに対して必ずPKの指定が必要であり、
また、複合キーには対応していないため、この例では中間テーブルに単一のキーとなる
idカラムを持たせています。

__PACKAGE__->many_to_many('categories');

__PACKAGE__->many_to_many(
    'categories' => {
        self_key     => 'id',
        target_class => 'Mock::Category',
        target_key   => 'id',
        glue => {
            table      => 'books_categories',
            self_key   => 'book_id',
            target_key => 'category_id',
        }
    }
);

many_to_manyのオプションは他の物よりも複雑です。

self_key ... 呼び出し元クラスのPK
target_class ... 取得する対象のクラス名
target_key ... 対象クラスのPK
glue ... 中間テーブルの情報
  table ... テーブル名
  self_key ... 呼び出し元の外部キー
  target_key ... 取得対象の外部キー

中間テーブル名を明示的に指定しなかった場合は、呼び出し元クラス名と対象クラス名をそれぞれ複数形にして、アンダースコアで挟んだ物が使用されます。「呼び出し元_対象」「対象_呼び出し元」の両方のパターンを試して、テーブルが見付かったらそれを使用します。
