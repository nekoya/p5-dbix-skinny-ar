=encoding utf8

=head1 NAME

DBIx::Skinny::AR::Manual::JA - DBIx::Skinny::ARについて

=head1 DESCRIPTION

DBIx::Skinny::ARはActiveRecord風味なインタフェースを持った、小さなラッパーです。

主に以下の機能をサポートしています。
-ARライクなfind/find_all
-create/update時の自動バリデート
-いくつかのリレーション

=head1 SETUP

まず、DBIx::Skinny::ARを使用するベースクラスを定義します。

    package MyApp::DB::AR;
    use Any::Moose;
    extends 'DBIx::Skinny::AR';

    __PACKAGE__->setup({
        # Your DB class
        db => 'MyApp::DB',
        # Validator settings
        validator => {
            module  => 'FormValidator::Simple',
            plugins => [
                'FormValidator::Simple::Plugin::DBIC::Unique',
                'FormValidator::Simple::Plugin::Japanese',
            ],
        },
    });

    1;

各モジュールでこのクラスをextendsします。

    package MyApp::Book;
    use Any::Moose;
    extends 'MyApp::DB::AR';

    # DB table name
    sub table { 'books' }

    __PACKAGE__->mk_accessors;

    # class validation rules
    sub validation {
        [
            id   => [ qw/UINT/ ],
            name => [ qw/NOT_BLANK ASCII/ ],
            { name => [ qw/id name/ ] } => [ [ 'DBIC_UNIQUE', __PACKAGE__, '!id', 'name' ] ],
        ];
    }

    # relationships
    __PACKAGE__->belongs_to('author');

    1;

=head1 CRUD

=head2 find

default_search_columnで検索

    my $book = MyApp::Book->find(1);

MyApp::Bookのオブジェクトを返す。$book->rowにDBIx::Skinny::Rowが入ってる。

hashrefでwhereを指定

    my $book = MyApp::Book->find({ name => 'hoge' });

その他もろもろ付けて取ってくる

    my $book = MyApp::Book->find({ author_id => 1 }, { order_by => 'created_at' });

newしてからfindしてもOK

    my $model = MyApp::Book->new;
    my $book = $model->find(1);

$model->rowにDBIx::Skinny::Rowを取り込んで$selfを返す。$modelと$bookは同じオブジェクト。

=head2 find_all

全レコード取ってきて、全部MyApp::BookのオブジェクトにしてArrayRefに入れて返す。

    my $books = MyApp::Book->find_all;

whereとかoptもfindと同じように使える。

    MyApp::Book->find_all({ name => 'hoge' }, { limit => 5 });

newしてからfind_allしてもOK

    my $model = MyApp::Book->new;
    my $books = $model->find_all;

findと違ってArrayRefが返ってくるので、$modelと$booksは別物。

=head2 count

    my $count = MyApp::Book->count({ author_id => 1 });

今のところ select count(id) 固定なので、もう少し柔軟に。

=head2 create

    my $book = MyApp::Book->create({ name => 'fuga', author_id => 2 });

HashRefを最初にvalidateしてから、DBにレコードを作る。
validate失敗したらresultsをcroakする。FV::Simpleなら、

    isa_ok $@, 'FormValidator::Simple::Results';

=head2 update

今の状態をDBに保存する。

    $book->update;

HashRefを渡して直接updateかけることも出来る。

    $book->update({ name => 'gege' });

これもcreate同様、DBに書き込む前にvalidateする。

whereを渡して直接やってもいい。

    MyApp::Book->update({ name => 'hoge' }, { author_id => 1 });

=head2 delete

オブジェクトから

    $book->delete;

where指定して、クラスメソッドとして

    MyApp::Book->delete({ name => 'hoge' });

引数無しで実行したらcroak。全レコード削除なんて男前な事は出来ない。

    MyApp::Book->delete;  # die

=head1 VALIDATE

setup時にvalidatorとして使用するモジュールと、validator用のプラグインを指定する。
特に指定しなければFormValidator::Simpleを使用する。

=head2 validate

オブジェクトの内容をvalidate

    $book->validate;

引数にHashRefを投げると、今のオブジェクトの内容と結合してvalidateする。

    $book->validate({ name => 'hoge' });

とかやると、今の$bookの内容 + { name => 'hoge' } をvalidateする。
オブジェクトの内容自体は書き換えないので、「この変更は通るか？」を
純粋にチェック出来る。

create/updateと違って、単体で使った時はvalidate通らなかった時は
croakせずにundefを返す。

条件は、sub validationで定義する。

    sub validation {
        [
            id        => [ qw/UINT/ ],
            author_id => [ qw/NOT_BLANK UINT/ ],
            name      => [ qw/NOT_BLANK ASCII/ ],
            { name => [ qw/id name/ ] } => [ [ 'DBIC_UNIQUE', __PACKAGE__, '!id', 'name' ] ],
        ];
    }

=head1 RELATION

DBIx::Skinny::ARでは、

・クラス名は単数形
・primary keyはid
・外部キーはXXXX_id
・テーブル名は複数形

をデフォルトとしたリレーションの設定をサポートします。
これにマッチしない場合は、オプションを指定してください。

=head2 belongs_to

    __PACKAGE__->belongs_to($method);

で、対象にクラスに指定のメソッドが生えます。

外部キーと対象クラスをオプションで指定できます。

    __PACKAGE__->belongs_to($method => {
        key   => $foreign_key,
        class => $target_class,
    });

デフォルトでは呼び出し元と同一の名前空間から、
ucfirst $method したクラスを対象とします。
外部キーは $method . '_id' がデフォルトです。

例えば、

    package MyApp::Book;
    __PACKAGE__->belongs_to('author');

は

    __PACKAGE__->belongs_to('author' => {
        key   => 'author_id',
        class => 'MyApp::Author',
    });

と同等です。

    $book->author;

で取れます。内部的には、

    MyApp::Author->find({ id => $book->id });

を実行してます。

主従の関係において、主を持たない従は存在しないはずだという考えで、
対象のレコードが存在しない場合はcroakします。

=head2 has_one

has_oneはbelongs_toの逆です。

    package MyApp::Author;
    __PACKAGE__->has_one('book');

もしくは

    __PACKAGE__->belongs_to('book' => {
        key   => 'author_id',
        class => 'MyApp::Book',
    });

みたいに設定します。
違いは、keyが対象クラスの外部キー（自身を指す）なところです。

    $author->book;

すると、

    MyApp::Book->find({ author_id => $author->id });

が実行されます。

対象のレコードが存在しない場合はundefを返します。

=head2 has_many

基本的にhas_oneと同様ですが、複数のレコードを前提にしているので、
生やすメソッド名は複数形を想定しています。

    package MyApp::Author;
    __PACKAGE__->has_many('books');

オプションを指定する場合もhas_oneと同様です。省略した場合、
対象のクラスはメソッド名を単数形にした物をとります。
上記の例であれば、booksでMyApp::Bookが対象になります。

has_manyは常にArrayRefを返します。対象のレコードが一件も存在しない時は
空のArrayRefを返します。

=head2 many_to_many

中間テーブルを用いて、n:nの関係を表す時に使います。

             +-------------------+
+---------+  | members_languages |
| members |  +-------------------+  +-----------+
+---------+  | id                |  | languages |
| id      |--| member_id         |  +-----------+
| name    |  | language_id       |--| id        |
+---------+  +-------------------+  | name      |
                                    +-----------+
のような構成を想定しています。

中間テーブルがidを持っているのは、
今のところDBIx::Skinnyが単一のプライマリキーを必要としているためです。

MyApp::MemberからMyApp::Languageにmany_to_manyする場合は以下のようにします。

    __PACKAGE__->many_to_many('members' => { glue => 'member_languages' });

最初は他と同様にメソッド名を指定します。many_to_manyのみoptionが必須で、
最低限glueに中間テーブル名を指定する必要があります。

その他の指定可能なオプションは以下の通りです。

    __PACKAGE__->many_to_many('languages' => {
            glue   => 'member_languages',
            target => 'Mock::Language',
            key    => 'language_id',
            self   => 'member_id',
        });

targetが対象のクラス、keyが中間テーブルで持ってる対象クラスのidが入る外部キー名、
selfが自テーブルのidが入る外部キー名です。

=head1 与太話

=head2 動機

DBICを好きなインタフェースで使いたい

-ラッパーを書くのは大変＆メリットが薄い（本体が強力すぎる）
-JOINよりWHERE id IN $idsして欲しい
-貧弱なサーバで使うにはDBICは大きすぎる

リレーションってORMの仕事？

-その上の層で解決する方がスマートじゃない？
-DB分割対応
-概念的にはDB以外の物と結合できてもいいはず
-DB操作の機能ではなく、モデルのインタフェースとして捉える

DBICのリレーションを使わない → DBICみたいに高機能じゃなくていい

=head2 Meets DBIx::Skinny

Yokohama.pmでData::ModelとDBIx::Skinnyの話を聞く
「これ使えばいいんじゃね？」

Why not Data::Model ?
-Data::Modelは様々なモデルに抽象レイヤを挟み込むイメージ
-SkinnyはMySQL/SQLiteに限定したDBIの薄いラッパー
-概念が分かりやすい
-コードも多くないし、追いかけやすい

=head2 Validation

Modelの仕事か　Controllerの仕事か
-Controller : ユーザーの入力に対する検証
-Model : アプリ内のオブジェクトに対する検証
-両方あるのが自然な形に思える

書くのも変更するのも面倒じゃね？
-今後の課題

=head2 今後

とりあえず動かしてみたレベルなので、まだまだこれからです。
find系はnewしてから使えるのに、createはクラスメソッドとして呼んだ時しか
動かないなど、インタフェースの統一が出来ていない部分もあります。
元々はnewしてからDBレコードを取り込む操作は考えていなかったのですが、
Catalyst(or Ark)::Model::Adaptorで使うのに必要なので追加中です。

他にはDBやクラスの構成が気の向くままに実装しただけなので、
カラム名をidに固定している部分などはもう少し柔軟にしたいですね。
クラス名、テーブル名などの単数形、複数形の使い方も検討の余地あり。

DB的にはmany_to_manyの中間テーブルにidを持たせる必要はないので、
そのへんSkinnyとの兼ね合いでもう少し煮詰めたいところ。

バリデーション周りも今後どうするか不透明です。
本当にまだまだこれから。
